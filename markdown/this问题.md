####什么是this<br>
this是在运行时进行绑定的，而非在编写时绑定的<br>
所以它的上下文取决与函数调用时的各种条件，取决与函数的调用方式<br>
this只是函数被调用时创建的活动记录（或者说执行上下文）下面的一个属性罢了，这个记录记录了调用栈（函数在哪里被调用）、函数的调用方式和传入的参数


#### 常见错误的两种对于this的解释
1.指向自身<br>
以下代码证明
```
function foo(nums){
    console.log(this)
}
```
然而输出的是顶层对象window(this默认绑定)
> 如果需要绑定自身的函数可以通过具名函数.属性进行对内部成员变量对调用
另外一种方法是arguments.calle，但是已经弃用了，不建议使用

2.this指向函数对作用域

*需要明确的是在任何时候this都不指向函数作用域，但是在某种情况下是正确的*
因为函数作用域实际上只存在与javascript的引擎中，是无法通过代码来进行访问的（只能说作用域“对象”和对象类似罢了）

#### this调用位置解析
*调用栈（为了达到当前执行位置所调用的所有函数，可以理解为函数调用顺序执行链）*

#### 绑定规则
* 默认绑定<br>
*函数独立调用，不代任何修饰代函数。因为无法应用其他代规则，所以只能绑定默认值（严格模式下会绑定undfined）*

* 隐式绑定<br>
```
let obj = {
    a:2,
    foo:foo
}
function foo(){
    console.log(this.a);
    console.log(this)
}
obj.foo();
```
这段代码会输出<br>
this.a // 2<br>
this // {a:2,foo:foo} 也就是obj
因为在那个位置函数调用是在对象内段，所以会调用对象段执行上下文<br>
这时候this会绑定到obj<br>
如果有多个对象嵌套到话，this绑定到依然还是上一级对象的执行上下文

*隐式丢失*：<br>
```
function foo(){
    console.log(this.a);
}
var obj = {
    a:2,
    foo:f00
}
var bar = obj.foo;
var a = "not obj";
bar() //输出not obj
```
虽然bar是对obj.foo对引用，但实际上引用但是foo函数本身
因此此时但bar是一个不带修饰但函数调用，即上面所述过的默认绑定<br>
* 显式绑定
<br>通过call和apply进行执行上下文的绑定

* new绑定
在使用new实例化的时候<br>

    1.创建一个全新对象<br>
    2.这个新对象会被执行[[prototype]]连接
    3.新对象会绑定到函数调用的this
    4.如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象





