## 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？
* 给每一个Vnode一个id，可以更准确的绑定对应的Vnode
因为带key就不采用默认的就地复用策略了（不移动dom元素来匹配已改变数据项，而是简单的复用该数据项【意思就是比方说让一个第一个数据项下移，但是采用就地复用策略它不会匹配已改变的数据项，所以它后面一个移动到第一个数据项位置的元素将继承该元素的数据】）
* 就地复用原则可以更有效的复用节点，能提高性能
* key的使用，利用了key的唯一性生成的map对象来获取对应节点，这种方式比遍历来得快一些

## ['1','2','3'].map(parseInt)  what?why?
* 输出1,NaN.NaN
上面相当于执行下述程序
* ['1','2','3'].map（function(){
* parseInt(item,index)
* }）
* item->['1','2','3']
* index->0,1,2
* 传入的index为parseInt的进制位，parseInt默认十进制
* 当1传入时，index为0，0进制，默认为10进制，输出1
* 当2传入时，index为1，1进制，2大雨一进制最高位，无法识别，输出NaN
* 同理3

## 函数防抖，函数节流：
#### 函数防抖：
* 代码不能在没有一定间隔的时间内连续重复执行
实现思想：第一次调用函数时创建定时器，在指定时间后执行代码
第二次及以后执行时，先清楚定时器再创建定时器，因为前一个定时器已经执行了的话，这个操作就没有意义了


#### 函数节流：
* 同一个函数，不能在一段时间内连续调用
防止用户频繁触发事件，造成ui页面崩溃之类的问题

## 深度优先遍历，广度优先遍历：
*深度优先遍历是指从某个顶点出发，首先访问这个顶点，然后找出刚访问这个结点的第一个未被访问的邻结点，然后再以此邻结点为顶点，继续找它的下一个顶点进行访问。重复此步骤，直至所有结点都被访问完为止.*

*广度优先遍历是从某个顶点出发，首先访问这个顶点，然后找出刚访问这个结点所有未被访问的邻结点，访问完后再访问这些结点中第一个邻结点的所有结点，重复此方法，直到所有结点都被访问完为止。*

#### 深度优先遍历(DFS)实现：
 ```
    let deepTraversal = (node,nodeList=[])=>{
        if(node !== null){
        nodeList.push(node);
        let children = node.children;
        for(let i =0;i<children.length;i++){
        deepTraversal(children[i],nodeList); 递归子节点
        }
        }
        return nodeList;
    }
 ```

 #### 广度优先遍历（BFS）实现：
 ```
 let wideTraversal = function(node){
    let nodeList=[];
    let i = 0;
    while(node !== null){
    nodeList.push(node);
    node = nodeList[i++];
    let children = node.children;
    for(let j =0;j<children.length;j++){
    nodeList.push(children[i]);
    }
    }
    return nodeList;
 }
 ```

 ## ES5/6的继承于其他继承的区别：
 * class 存在变量提升，但不会赋初始值
 * 内部采用严格模式，不可以给未定义的变量赋值
 * class的所有方法不可枚举
 * class类中的方法没有原型
 * 必须使用new来调用class
 * class内部无法重写类名

 ## 已知如下数组： var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]; 编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组

* 直接一点就是递归实现
* 优雅简便一点就是：
* Array.from(new Set(arr.flat(Infinity))).sort((a,b)=>{return a-b});
* arr.flat() 按照传入的深度递归数组，将数组下的元素和子数组合并到一个人新数组里

* new Set()实现数组去重，Set对象的成员唯一且无序

* Array.from() 将可迭代或类数组中创建一个数组实例（返回一个数组）

## HTTP2多路复用
* 在多路复用前不得不提流的概念

* 流指的是数据流，在服务端和客户端相互传输数据的通道

* HTTP1.x中，同个域名下的不同请求，会有多个tcp连接
而http2中同个域名下所有的请求只用到一个连接，多个请求并行交错在连接上，互不干扰

* 可以理解为，一个连接上有多个流，每个流互不干扰

## 关于let,const,class定义的变量不在windows对象：
* windows对象也叫顶层对象，es6规定上述关键字定义的全局变量不再是顶层变量的属性
* 而var和function 定义的全局变量依旧是顶层对象下的属性

## 介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？
#### 1. npm 模块安装机制：
1.发出npm install命令
2.查询node_modules目录之中是否已经存在指定模块
   2.1若存在，不再重新安装
   2.2若不存在
      2.2.1npm 向 registry 查询模块压缩包的网址
      2.2.2下载压缩包，存放在根目录下的.npm目录里
      2.2.3解压压缩包到当前项目的node_modules目录